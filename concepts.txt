* = complete with solution
+ = challenge written, needs solution/writeup

-- PHYSICAL --
100 - [Challenge Name] - [Challenge Description]
200 - [Challenge Name] - [Challenge Description]
300 - [Challenge Name] - [Challenge Description]

-- PWN --
100 - [Challenge Name] - [Challenge Description]
300 - pwnchess - You're presented with an x86-64 Linux binary and a copy of libc.so running on the remote
server.  The binary is compiled with all default anti-exploit mitigations except for PIE.  The binary allows the
you to peform one of three operations; read one byte at an arbitrary, write one byte to an arbitrary location,
or exit.  The catch is that you are allowed to perform only 2 operations.  So first you must write a larger value
to the global variable moves memory address to unlike up-to 255 moves.  Next, you will have to leak the libc address
by performing multiple reads to an address from the GOT section.  Once a libc address is leaked, offsets can be calculated
using the provided version of libc.  Then, you use the free leak the application gives to the stack to calculate the
address on the stack where the return address is read from.  You can finally write a ret2libc ROP chain to this location,
and finally either exhaust all remaining moves or write 0 to the moves address to trigger the ROP chain.

-- RE --
100 - Magic Numbers - You're presented with an x86-64 Linux binary.  The binary will notify the user that
there are 3 magic numbers they must find.  These numbers are static, hardcoded values.  After each number is
entered, the binary will either tell the user that the number is incorrect or prompt for the next number.
Once all 3 numbers are correctly entered, the program will "decrypt" and print out the flag.
300 - Bad CryptXor - You're presented with an x86-64 Linux binary as well as an encrypted file.  The program used
to encrypt the file is a pretty simple XOR cipher, however, the file is hidden behind a password-protected, custom
cryptor.  So the user will have to unwind the cryptor or use a debugger to reveal the embedded 2nd binary.

-- MISC/FORENSICS --
100 - [Challenge Name] - [Challenge Description]
200 - [Challenge Name] - [Challenge Description]
300 - [Challenge Name] - [Challenge Description]

-- WEB --
100 - Signed, Sealed, Delivered, I'm Yours! - You're presented with a register/login page. You can register
and login to accounts. Once logged in, there's a button that says "Get Flag". If you click it, you'll get an
error saying you're unauthorized. The solution is to modify the JWT stored in localStorage and modify the
admin claim to be true, and change the signing algorithm to none. Since the server doesn't verify algorithm,
it accepts the none signing algorithm, and accepts that you're an "admin". When you hit "Get Flag" with this
crafted JWT, you get the flag.
200 - Yours truly - In this challenge there is no frontend at all. Instead, all that's given is the 
path to an OpenAPI document on a backend. This doc outlines an API for a service that returns Hackers 
characters, paths to images, and presigned URLs to those paths. You notice in the OpenAPI document 
that there's a commented out portion for a header called X-Debug-Characters. You expose an nginx 
server to the internet and pass it's URL in that header. You see a GET /users request, so you 
configure nginx to respond with a JSON blob that looks similar to the original backend response but 
with just the paths and names (no presigned URLs). You now see the backend is presigning whatever 
paths your server returns. You look again in the OpenAPI documentation and see a default value for the 
path in the response of a random UUID. You try returning this path from your fake server, and get a 
presigned URL for it. You go to the URL and an image containing the flag is returned.
300 - Hell.js - You're presented with a login page. You don't have a username/password and no SQL injection works.
After noticing the backend responding with X-Powered-By: Express, you assume it might be using MongoDB. You end up
searching around for common MongoDB vulns and find MongoDB injection. You pass {"$gt": ""} to the server for the
username and password and are able to login. You are now greeted with a table of items that allows you to search
via queries formatted like "return false;". You can also see that the browser is making requests to a different server with
the endpoint `/flag`, however this server is always responding with 403 Forbidden. You look at your JWT and see
that a claim named "get_flag" is set to false. You try setting the algorithm to "none" like the 100 challenge, but
no dice. You move on to looking at the table since you're not getting anywhere. You try another MongoDB injection,
but it doesn't work since the server is using an explicit query selector this time. Instead, since the query looks
like Javascript and you think the server is running Node, you craft queries like this to exfiltrate the JWT secret:
`customer.gender = JSON.stringify(process.env); return true;`. Since you know the JWT is signed with
HS256 from inspecting it in jwt.io you use the secret to sign a version of your token with the "get_flag" claim
set to true and make a request to the other server with the flag endpoint. It returns the flag.