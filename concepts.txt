* = complete with solution
+ = challenge written, needs solution/writeup

-- PHYSICAL --
100 - [Challenge Name] - [Challenge Description]
200 - [Challenge Name] - [Challenge Description]
300 - [Challenge Name] - [Challenge Description]

-- PWN --
100 - [Challenge Name] - [Challenge Description]
300 - [Challenge Name] - [Challenge Description]

-- RE --
100 - Caesar Shift 2.0 - You're presented with an x86-64 Linux binary.  The binary will ask for a password
from the user.  Once the user enters the password in, the program will "encrypt" the input, and perform a
memcmp on the "encrypted" version of the password.  The "encryption" will be relatively simple.  It will
iterate over the input characters, for every even character it will increment the byte by an arbitrary value.
For every odd character, it will decrement the byte by another arbitrary value.  I will include debug symbols
and lots of print messages.  The goal is for this challenge to be solvable by someone who is using Ghidra for
the first time.  But it should be hard enough that it requires Ghidra or another dissassembler.
300 - [Challenge Name] - [Challenge Description]

-- MISC/FORENSICS --
100 - [Challenge Name] - [Challenge Description]
200 - [Challenge Name] - [Challenge Description]
300 - [Challenge Name] - [Challenge Description]

-- WEB --
100 - Signed, Sealed, Delivered, I'm Yours! - You're presented with a register/login page. You can register
and login to accounts. Once logged in, there's a button that says "Get Flag". If you click it, you'll get an
error saying you're unauthorized. The solution is to modify the JWT stored in localStorage and modify the
admin claim to be true, and change the signing algorithm to none. Since the server doesn't verify algorithm,
it accepts the none signing algorithm, and accepts that you're an "admin". When you hit "Get Flag" with this
crafted JWT, you get the flag.
200 - [Challenge Name] - [Challenge Description]
300 - [Challenge Name] - [Challenge Description]
